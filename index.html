<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <link rel="stylesheet" href="./shadowcrypt.css">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ShadowCrypt - Dark Fantasy Dungeon Crawler</title>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;600;700&display=swap" rel="stylesheet">
    <style>

</head>
<body>
    <div class="game-container">
        <div class="game-area">
            <canvas id="game-canvas" width="900" height="700"></canvas>
            
            <!-- Door Elements -->
            <div class="door top" id="door-top" data-direction="top">‚Üë</div>
            <div class="door bottom" id="door-bottom" data-direction="bottom">‚Üì</div>
            <div class="door left" id="door-left" data-direction="left">‚Üê</div>
            <div class="door right" id="door-right" data-direction="right">‚Üí</div>
            
            <!-- Room Transition Overlay -->
            <div class="room-transition" id="room-transition"></div>
            
            <!-- Merchant -->
            <div class="merchant" id="merchant">
                <div class="section-title">Mercador das Sombras</div>
                <div>Seu ouro: <span id="merchant-gold">0</span></div>
                <div class="merchant-items" id="merchant-items">
                    <!-- Merchant items will be populated by JS -->
                </div>
                <button class="btn" id="close-merchant" style="margin-top: 15px; pointer-events: auto;">Fechar</button>
            </div>
            
            <div class="ui-overlay">
                <div class="health-bar">
                    <div class="health-fill" id="health-fill"></div>
                </div>
                <div class="mana-bar">
                    <div class="mana-fill" id="mana-fill"></div>
                </div>
                
                <div class="player-stats">
                    <div>N√≠vel: <span class="stat-value" id="player-level">1</span></div>
                    <div>Dano: <span class="stat-value" id="player-damage">10-15</span></div>
                    <div>Defesa: <span class="stat-value" id="player-defense">5</span></div>
                    <div>Ouro: <span class="stat-value" id="player-gold">0</span></div>
                </div>
                
                <div class="floor-indicator">
                    Dungeon: <span id="floor-number">1</span> - Sala: <span id="room-number">1</span>
                </div>
                
                <div class="enemy-health" id="enemy-health">
                    <div id="enemy-name">Esqueleto</div>
                    <div class="health-bar" style="width: 120px; margin-top: 5px;">
                        <div class="health-fill" id="enemy-health-fill"></div>
                    </div>
                </div>
                
                <!-- Mini Map -->
                <div class="mini-map">
                    <div class="section-title">Mapa</div>
                    <div class="mini-map-grid" id="mini-map">
                        <!-- Mini map will be populated by JS -->
                    </div>
                </div>
            </div>
        </div>
        
        <div class="sidebar">
            <div class="equipment">
                <div class="section-title">Equipamento</div>
                <div class="equipment-slots">
                    <div class="equipment-slot" data-slot="weapon">
                        <div class="equipment-slot-type">Arma</div>
                        <div id="equipped-weapon">-</div>
                    </div>
                    <div class="equipment-slot" data-slot="armor">
                        <div class="equipment-slot-type">Armadura</div>
                        <div id="equipped-armor">-</div>
                    </div>
                </div>
            </div>
            
            <div class="inventory">
                <div class="section-title">Invent√°rio</div>
                <div class="inventory-slots" id="inventory-slots">
                    <!-- Inventory slots will be populated by JS -->
                </div>
            </div>
            
            <div class="skills">
                <div class="section-title">Habilidades</div>
                <div class="skill-slots" id="skill-slots">
                    <!-- Skills will be populated by JS -->
                </div>
            </div>
            
            <div class="quest-log">
                <div class="section-title">Miss√µes</div>
                <div class="quest-list" id="quest-list">
                    <!-- Quests will be populated by JS -->
                </div>
            </div>
        </div>
        
        <!-- Start Screen -->
        <div class="screen start-screen">
            <div class="title">SHADOWCRYPT</div>
            <div class="subtitle">Um jogo de Dark Fantasy Dungeon Crawler. Explore masmorras amaldi√ßoadas, enfrente hordas de n√£o-mortos e descubra segredos antigos.</div>
            <button class="btn btn-primary" id="start-btn">Iniciar Jornada</button>
        </div>
        
        <!-- Game Over Screen -->
        <div class="screen game-over" style="display: none;">
            <div class="title">FIM DE JOGO</div>
            <div class="subtitle">Sua jornada termina aqui, nas profundezas de ShadowCrypt...</div>
            <div id="game-over-stats" style="margin-bottom: 30px; text-align: center;">
                <!-- Game over stats will be populated by JS -->
            </div>
            <button class="btn btn-primary" id="restart-btn">Tentar Novamente</button>
        </div>
    </div>
    
    <div class="tooltip" id="tooltip"></div>

    <script>
        // =============================================
        // GAME ENGINE & CORE SYSTEMS
        // =============================================
        
        // Canvas setup
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        
        // Game state
        let gameState = 'menu'; // menu, playing, paused, gameOver
        let player = {};
        let currentFloor = 1;
        let currentRoom = 1;
        let rooms = [];
        let enemies = [];
        let items = [];
        let projectiles = [];
        let particles = [];
        let combatTexts = [];
        let roomCleared = false;
        let visitedRooms = new Set();
        let stairsLocation = null;
        let merchantRoom = null;
        
        // Game data - Agora o personagem pode usar qualquer equipamento
        const weaponTypes = [
            // Espadas (todas as classes)
            { name: 'Espada Curta', damage: [8, 12], rarity: 'common', icon: '‚öîÔ∏è', type: 'sword' },
            { name: 'Espada Longa', damage: [12, 18], rarity: 'uncommon', icon: '‚öîÔ∏è', type: 'sword' },
            { name: 'Espada Bastarda', damage: [15, 22], rarity: 'rare', icon: 'üó°Ô∏è', type: 'sword' },
            { name: 'L√¢mina Sombria', damage: [20, 30], rarity: 'epic', icon: 'üó°Ô∏è', type: 'sword' },
            { name: 'Espada do Rei Ca√≠do', damage: [25, 40], rarity: 'legendary', icon: '‚öîÔ∏è', type: 'sword' },
            
            // Machados
            { name: 'Machado de Batalha', damage: [10, 16], rarity: 'common', icon: 'ü™ì', type: 'axe' },
            { name: 'Machado Duplo', damage: [14, 22], rarity: 'uncommon', icon: 'ü™ì', type: 'axe' },
            { name: 'Machado do Carrasco', damage: [18, 28], rarity: 'rare', icon: '‚õèÔ∏è', type: 'axe' },
            { name: 'Machado √âlfico', damage: [22, 35], rarity: 'epic', icon: 'ü™ì', type: 'axe' },
            { name: 'Machado do Tit√£', damage: [28, 45], rarity: 'legendary', icon: '‚õèÔ∏è', type: 'axe' },
            
            // Cajados/Varinhas (magos)
            { name: 'Cajado Simples', damage: [5, 8], rarity: 'common', icon: 'ü¶Ø', type: 'staff' },
            { name: 'Varinha Arcana', damage: [8, 12], rarity: 'uncommon', icon: '‚ú®', type: 'staff' },
            { name: 'Cetro do Arcanista', damage: [12, 18], rarity: 'rare', icon: 'üîÆ', type: 'staff' },
            { name: 'Cajado do V√°cuo', damage: [15, 25], rarity: 'epic', icon: 'üåå', type: 'staff' },
            { name: 'Cetro do Arquimago', damage: [20, 35], rarity: 'legendary', icon: 'üåü', type: 'staff' },
            
            // Arcos (ladinos)
            { name: 'Arco Curto', damage: [6, 10], rarity: 'common', icon: 'üèπ', type: 'bow' },
            { name: 'Arco Longo', damage: [9, 14], rarity: 'uncommon', icon: 'üèπ', type: 'bow' },
            { name: 'Arco Composto', damage: [12, 19], rarity: 'rare', icon: 'üéØ', type: 'bow' },
            { name: 'Arco √âlfico', damage: [16, 26], rarity: 'epic', icon: 'üèπ', type: 'bow' },
            { name: 'Arco do Ca√ßador', damage: [20, 32], rarity: 'legendary', icon: 'üéØ', type: 'bow' }
        ];

        const armorTypes = [
            { name: 'Armadura de Couro', defense: 3, rarity: 'common', icon: 'üß•' },
            { name: 'Cota de Malha', defense: 6, rarity: 'uncommon', icon: '‚õìÔ∏è' },
            { name: 'Armadura de Placas', defense: 10, rarity: 'rare', icon: 'üõ°Ô∏è' },
            { name: 'Armadura √âlfica', defense: 15, rarity: 'epic', icon: 'üçÉ' },
            { name: 'Armadura do Drag√£o', defense: 25, rarity: 'legendary', icon: 'üêâ' }
        ];

        const floorEnemies = {
            1: ['skeleton', 'zombie'],
            2: ['skeleton', 'zombie', 'ghost'],
            3: ['ghost', 'wraith', 'vampire'],
            4: ['vampire', 'lich', 'demon'],
            5: ['demon', 'ancient_dragon', 'shadow_lord']
        };

        const floorBosses = {
            1: { name: 'Lich Senhor das Trevas', type: 'lich' },
            2: { name: 'Vampiro Ancestral', type: 'vampire_lord' },
            3: { name: 'Rei Esqueleto', type: 'skeleton_king' },
            4: { name: 'Dem√¥nio do Abismo', type: 'abyssal_demon' },
            5: { name: 'Drag√£o Ancestral', type: 'ancient_dragon' }
        };

        // Input handling
        const keys = {};
        const mouse = { x: 0, y: 0, down: false };
        
        // Game systems
        const game = {
            // Core game loop
            loop: function() {
                if (gameState !== 'playing') return;
                
                this.update();
                this.render();
                requestAnimationFrame(() => this.loop());
            },
            
            // Update game state
            update: function() {
                this.updatePlayer();
                this.updateEnemies();
                this.updateProjectiles();
                this.updateParticles();
                this.updateCombatTexts();
                this.checkCollisions();
                this.updateUI();
                this.updateDoors();
                this.updateMiniMap();
                
                // Update player attack cooldown
                if (player.attackCooldown > 0) {
                    player.attackCooldown--;
                }

                // Update skill cooldowns
                player.skills.forEach(skill => {
                    if (skill.cooldown > 0) {
                        skill.cooldown--;
                    }
                });
            },
            
            // Update door states
            updateDoors: function() {
                // Check if room is cleared
                if ((enemies.length === 0 && !roomCleared) || rooms[currentRoom]?.type === 'merchant' || rooms[currentRoom]?.type === 'stairs') {
                    roomCleared = true;
                    this.unlockDoors();
                }
                
                // Update door visibility
                const directions = ['top', 'bottom', 'left', 'right'];
                directions.forEach(direction => {
                    const door = document.getElementById(`door-${direction}`);
                    if (this.hasDoor(direction)) {
                        door.style.display = 'flex';
                        if (roomCleared) {
                            door.classList.remove('locked');
                        } else {
                            door.classList.add('locked');
                        }
                    } else {
                        door.style.display = 'none';
                    }
                });
            },
            
            // Update mini map - CORRIGIDO
            updateMiniMap: function() {
                visitedRooms.add(currentRoom);
                const miniMap = document.getElementById('mini-map');
                miniMap.innerHTML = '';
                
                // Mapa 5x5
                for (let row = 0; row < 5; row++) {
                    for (let col = 0; col < 5; col++) {
                        const roomNumber = row * 5 + col + 1;
                        const roomElement = document.createElement('div');
                        roomElement.className = 'mini-map-room';
                        
                        if (roomNumber === currentRoom) {
                            roomElement.classList.add('current');
                            roomElement.textContent = '‚óè';
                        } else if (visitedRooms.has(roomNumber)) {
                            roomElement.classList.add('visited');
                            
                            // Adicionar √≠cones para salas especiais
                            if (roomNumber === stairsLocation) {
                                roomElement.classList.add('stairs');
                                roomElement.textContent = '‚§ä';
                            } else if (roomNumber === merchantRoom) {
                                roomElement.classList.add('merchant');
                                roomElement.textContent = 'üí∞';
                            } else if (rooms[roomNumber]?.type === 'boss') {
                                roomElement.classList.add('boss');
                                roomElement.textContent = 'üëë';
                            } else {
                                roomElement.textContent = '‚ñ™';
                            }
                        }
                        
                        miniMap.appendChild(roomElement);
                    }
                }
            },
            
            // Check if current room has a door in specified direction - CORRIGIDO
            hasDoor: function(direction) {
                if (!rooms[currentRoom] || !rooms[currentRoom].doors) return false;
                
                const room = rooms[currentRoom];
                let targetRoom;
                
                switch(direction) {
                    case 'top': targetRoom = currentRoom - 5; break;
                    case 'bottom': targetRoom = currentRoom + 5; break;
                    case 'left': targetRoom = currentRoom - 1; break;
                    case 'right': targetRoom = currentRoom + 1; break;
                }
                
                // Verificar se o quarto alvo existe
                return targetRoom >= 1 && targetRoom <= 25 && room.doors[direction];
            },
            
            // Unlock all doors when room is cleared
            unlockDoors: function() {
                const directions = ['top', 'bottom', 'left', 'right'];
                directions.forEach(direction => {
                    const door = document.getElementById(`door-${direction}`);
                    if (door.style.display !== 'none') {
                        door.classList.remove('locked');
                    }
                });
            },
            
            // Move to another room - CORRIGIDO
            changeRoom: function(direction) {
                if (!roomCleared && rooms[currentRoom]?.type !== 'merchant' && rooms[currentRoom]?.type !== 'stairs') return;
                
                // Fade to black
                const transition = document.getElementById('room-transition');
                transition.style.opacity = '1';
                
                setTimeout(() => {
                    // Calculate new room based on direction
                    let newRoom = currentRoom;
                    
                    switch(direction) {
                        case 'top': newRoom -= 5; break;
                        case 'bottom': newRoom += 5; break;
                        case 'left': newRoom -= 1; break;
                        case 'right': newRoom += 1; break;
                    }
                    
                    // Validate room number
                    if (newRoom >= 1 && newRoom <= 25) {
                        currentRoom = newRoom;
                        this.generateRoom();
                        
                        // Position player based on door entered
                        this.positionPlayerFromDoor(direction);
                    }
                    
                    // Fade back in
                    setTimeout(() => {
                        transition.style.opacity = '0';
                    }, 300);
                }, 500);
            },
            
            // Position player based on which door they entered from
            positionPlayerFromDoor: function(direction) {
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                
                switch(direction) {
                    case 'top':
                        player.x = centerX;
                        player.y = canvas.height - 100;
                        break;
                    case 'bottom':
                        player.x = centerX;
                        player.y = 100;
                        break;
                    case 'left':
                        player.x = canvas.width - 100;
                        player.y = centerY;
                        break;
                    case 'right':
                        player.x = 100;
                        player.y = centerY;
                        break;
                }
            },
            
            // Render game
            render: function() {
                // Clear canvas
                ctx.fillStyle = '#0a0a0f';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Draw room
                this.drawRoom();
                
                // Draw items
                this.drawItems();
                
                // Draw enemies
                this.drawEnemies();
                
                // Draw player
                this.drawPlayer();
                
                // Draw projectiles
                this.drawProjectiles();
                
                // Draw particles
                this.drawParticles();
                
                // Draw combat text
                this.drawCombatTexts();
                
                // Draw NPCs and interactive elements
                this.drawInteractiveElements();
            },
            
            // Draw interactive elements like merchant and stairs
            drawInteractiveElements: function() {
                if (rooms[currentRoom]?.type === 'merchant') {
                    this.drawMerchant();
                } else if (rooms[currentRoom]?.type === 'stairs') {
                    this.drawStairs();
                }
            },
            
            // Draw merchant
            drawMerchant: function() {
                const merchant = rooms[currentRoom].merchant;
                ctx.fillStyle = '#daa520';
                ctx.beginPath();
                ctx.arc(merchant.x, merchant.y, 20, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = '#ffffff';
                ctx.font = '16px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('üí∞', merchant.x, merchant.y);
                
                // Draw merchant text
                ctx.fillStyle = '#daa520';
                ctx.font = '14px Arial';
                ctx.fillText('Mercador (E)', merchant.x, merchant.y - 30);
            },
            
            // Draw stairs
            drawStairs: function() {
                const stairs = rooms[currentRoom].stairs;
                ctx.fillStyle = '#daa520';
                ctx.font = '24px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('‚§ä', stairs.x, stairs.y);
                
                ctx.fillStyle = '#daa520';
                ctx.font = '14px Arial';
                ctx.fillText('Escadas (E)', stairs.x, stairs.y - 30);
            },
            
            // Player update logic
            updatePlayer: function() {
                // Movement
                let moveX = 0, moveY = 0;
                
                if (keys['w'] || keys['ArrowUp']) moveY -= player.speed;
                if (keys['s'] || keys['ArrowDown']) moveY += player.speed;
                if (keys['a'] || keys['ArrowLeft']) moveX -= player.speed;
                if (keys['d'] || keys['ArrowRight']) moveX += player.speed;
                
                // Normalize diagonal movement
                if (moveX !== 0 && moveY !== 0) {
                    moveX *= 0.707;
                    moveY *= 0.707;
                }
                
                // Update position with collision detection
                const newX = player.x + moveX;
                const newY = player.y + moveY;
                
                if (!this.checkWallCollision(newX, player.y)) {
                    player.x = newX;
                }
                if (!this.checkWallCollision(player.x, newY)) {
                    player.y = newY;
                }
                
                // Update player direction based on mouse
                const dx = mouse.x - player.x;
                const dy = mouse.y - player.y;
                player.angle = Math.atan2(dy, dx);
                
                // Regenerate mana
                if (player.mana < player.maxMana) {
                    player.mana += 0.02;
                    if (player.mana > player.maxMana) player.mana = player.maxMana;
                }
                
                // Handle continuous attack when mouse is held down
                if (mouse.down && player.attackCooldown <= 0) {
                    this.playerAttack();
                }

                // Check for interactions
                if (keys['e']) {
                    this.checkInteractions();
                    keys['e'] = false; // Prevent holding E
                }
            },
            
            // Check for interactions with NPCs and objects
            checkInteractions: function() {
                // Check merchant
                if (rooms[currentRoom]?.type === 'merchant') {
                    const merchant = rooms[currentRoom].merchant;
                    const dx = player.x - merchant.x;
                    const dy = player.y - merchant.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < 50) {
                        this.openMerchant();
                        return;
                    }
                }
                
                // Check stairs
                if (rooms[currentRoom]?.type === 'stairs') {
                    const stairs = rooms[currentRoom].stairs;
                    const dx = player.x - stairs.x;
                    const dy = player.y - stairs.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < 50) {
                        this.nextFloor();
                        return;
                    }
                }
            },
            
            // Enemy update logic
            updateEnemies: function() {
                enemies.forEach((enemy, index) => {
                    if (enemy.health <= 0) {
                        // Enemy died
                        this.createParticles(enemy.x, enemy.y, 10, '#8b0000');
                        this.addCombatText('+' + enemy.goldReward + ' ouro', enemy.x, enemy.y, '#daa520');
                        
                        player.gold += enemy.goldReward;
                        player.exp += enemy.expReward;
                        
                        // Check for level up
                        if (player.exp >= player.expToNextLevel) {
                            player.level++;
                            player.exp -= player.expToNextLevel;
                            player.expToNextLevel = Math.floor(player.expToNextLevel * 1.5);
                            player.skillPoints++;
                            
                            // Increase stats
                            player.maxHealth += 10;
                            player.health = player.maxHealth;
                            player.maxMana += 5;
                            player.mana = player.maxMana;
                            player.damageMin += 1;
                            player.damageMax += 2;
                            
                            this.addCombatText('N√≠vel Up!', player.x, player.y - 30, '#00ff00');
                        }
                        
                        // Remove enemy
                        enemies.splice(index, 1);
                        
                        // Spawn loot from boss
                        if (enemy.type.includes('boss')) {
                            this.spawnBossChest(enemy.x, enemy.y);
                        } else {
                            // Spawn regular loot (chance reduzida)
                            if (Math.random() < 0.1) { // 10% chance instead of 30%
                                this.spawnLoot(enemy.x, enemy.y);
                            }
                        }
                        
                        return;
                    }
                    
                    // Enemy AI
                    const dx = player.x - enemy.x;
                    const dy = player.y - enemy.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < enemy.aggroRange) {
                        // Move toward player
                        if (distance > enemy.attackRange) {
                            enemy.x += (dx / distance) * enemy.speed;
                            enemy.y += (dy / distance) * enemy.speed;
                        }
                        
                        // Attack if in range
                        if (distance <= enemy.attackRange && enemy.attackCooldown <= 0) {
                            this.enemyAttack(enemy);
                            enemy.attackCooldown = enemy.attackSpeed;
                        }
                    }
                    
                    // Update attack cooldown
                    if (enemy.attackCooldown > 0) {
                        enemy.attackCooldown--;
                    }
                });
            },
            
            // Projectile update logic
            updateProjectiles: function() {
                for (let i = projectiles.length - 1; i >= 0; i--) {
                    const projectile = projectiles[i];
                    projectile.x += projectile.vx;
                    projectile.y += projectile.vy;
                    projectile.lifetime--;
                    
                    // Remove if lifetime expired or out of bounds
                    if (projectile.lifetime <= 0 || 
                        projectile.x < 0 || projectile.x > canvas.width || 
                        projectile.y < 0 || projectile.y > canvas.height) {
                        projectiles.splice(i, 1);
                    }
                }
            },
            
            // Particle update logic
            updateParticles: function() {
                for (let i = particles.length - 1; i >= 0; i--) {
                    const particle = particles[i];
                    particle.x += particle.vx;
                    particle.y += particle.vy;
                    particle.life--;
                    particle.alpha = particle.life / particle.maxLife;
                    
                    if (particle.life <= 0) {
                        particles.splice(i, 1);
                    }
                }
            },
            
            // Combat text update
            updateCombatTexts: function() {
                for (let i = combatTexts.length - 1; i >= 0; i--) {
                    const text = combatTexts[i];
                    text.y -= 1;
                    text.life--;
                    text.alpha = text.life / text.maxLife;
                    
                    if (text.life <= 0) {
                        combatTexts.splice(i, 1);
                    }
                }
            },
            
            // Collision detection
            checkCollisions: function() {
                // Player vs Enemy projectiles
                for (let i = projectiles.length - 1; i >= 0; i--) {
                    const projectile = projectiles[i];
                    if (projectile.isEnemy) {
                        const dx = player.x - projectile.x;
                        const dy = player.y - projectile.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance < player.size + projectile.size) {
                            // Player hit
                            const damage = this.calculateDamage(projectile.damage, player.defense);
                            player.health -= damage;
                            
                            this.addCombatText('-' + damage, player.x, player.y, '#ff0000');
                            this.createParticles(player.x, player.y, 5, '#ff0000');
                            
                            projectiles.splice(i, 1);
                            
                            if (player.health <= 0) {
                                this.gameOver();
                            }
                        }
                    }
                }
                
                // Player projectiles vs Enemies
                for (let i = projectiles.length - 1; i >= 0; i--) {
                    const projectile = projectiles[i];
                    if (!projectile.isEnemy) {
                        for (let j = enemies.length - 1; j >= 0; j--) {
                            const enemy = enemies[j];
                            const dx = enemy.x - projectile.x;
                            const dy = enemy.y - projectile.y;
                            const distance = Math.sqrt(dx * dx + dy * dy);
                            
                            if (distance < enemy.size + projectile.size) {
                                // Enemy hit
                                let damage = this.calculateDamage(projectile.damage, enemy.defense);
                                
                                // Critical hit chance
                                if (Math.random() < player.critChance) {
                                    damage = Math.floor(damage * player.critMultiplier);
                                    this.addCombatText('CR√çTICO!', enemy.x, enemy.y - 20, '#ff4500');
                                }
                                
                                enemy.health -= damage;
                                
                                this.addCombatText('-' + damage, enemy.x, enemy.y, '#ff0000');
                                this.createParticles(enemy.x, enemy.y, 3, '#ff0000');
                                
                                projectiles.splice(i, 1);
                                break;
                            }
                        }
                    }
                }
                
                // Player vs Items
                for (let i = items.length - 1; i >= 0; i--) {
                    const item = items[i];
                    const dx = player.x - item.x;
                    const dy = player.y - item.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < player.size + item.size) {
                        // Collect item
                        this.collectItem(item);
                        items.splice(i, 1);
                    }
                }
            },
            
            // UI update
            updateUI: function() {
                // Update health and mana bars
                document.getElementById('health-fill').style.width = (player.health / player.maxHealth * 100) + '%';
                document.getElementById('mana-fill').style.width = (player.mana / player.maxMana * 100) + '%';
                
                // Update player stats
                document.getElementById('player-level').textContent = player.level;
                
                // Calculate damage with equipment
                let minDmg = player.damageMin;
                let maxDmg = player.damageMax;
                if (player.equippedWeapon) {
                    minDmg += player.equippedWeapon.damage[0];
                    maxDmg += player.equippedWeapon.damage[1];
                }
                
                document.getElementById('player-damage').textContent = minDmg + '-' + maxDmg;
                document.getElementById('player-defense').textContent = player.defense;
                document.getElementById('player-gold').textContent = player.gold;
                
                // Update floor and room info
                document.getElementById('floor-number').textContent = currentFloor;
                document.getElementById('room-number').textContent = currentRoom;
                
                // Update enemy health bar if enemy is targeted
                if (enemies.length > 0) {
                    const enemy = enemies[0];
                    document.getElementById('enemy-health').style.display = 'block';
                    document.getElementById('enemy-name').textContent = enemy.name;
                    document.getElementById('enemy-health-fill').style.width = (enemy.health / enemy.maxHealth * 100) + '%';
                } else {
                    document.getElementById('enemy-health').style.display = 'none';
                }
                
                // Update skill cooldowns in UI
                player.skills.forEach((skill, index) => {
                    const skillElements = document.querySelectorAll('.skill');
                    if (skillElements[index]) {
                        if (skill.cooldown > 0) {
                            skillElements[index].style.opacity = '0.5';
                            skillElements[index].querySelector('.skill-cooldown').textContent = Math.ceil(skill.cooldown / 60) + 's';
                        } else {
                            skillElements[index].style.opacity = '1';
                            skillElements[index].querySelector('.skill-cooldown').textContent = skill.manaCost + ' MP';
                        }
                    }
                });

                // Update equipped items
                document.getElementById('equipped-weapon').textContent = player.equippedWeapon ? 
                    player.equippedWeapon.icon + ' ' + player.equippedWeapon.name : '-';
                document.getElementById('equipped-armor').textContent = player.equippedArmor ? 
                    player.equippedArmor.icon + ' ' + player.equippedArmor.name : '-';
            },
            
            // =============================================
            // RENDERING FUNCTIONS
            // =============================================
            
            drawRoom: function() {
                // Draw floor
                ctx.fillStyle = '#1a1a2e';
                ctx.fillRect(50, 50, canvas.width - 100, canvas.height - 100);
                
                // Draw walls
                ctx.strokeStyle = '#2d2d4d';
                ctx.lineWidth = 4;
                ctx.strokeRect(50, 50, canvas.width - 100, canvas.height - 100);
                
                // Draw room details based on type
                if (rooms[currentRoom]?.type === 'merchant') {
                    this.drawMerchantRoom();
                } else if (rooms[currentRoom]?.type === 'stairs') {
                    this.drawStairsRoom();
                } else if (rooms[currentRoom]?.type === 'boss') {
                    this.drawBossRoom();
                } else {
                    this.drawNormalRoom();
                }
            },
            
            drawNormalRoom: function() {
                // Draw torches
                ctx.fillStyle = '#8b0000';
                ctx.beginPath();
                ctx.arc(80, 80, 10, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = '#8b0000';
                ctx.beginPath();
                ctx.arc(canvas.width - 80, 80, 10, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = '#8b0000';
                ctx.beginPath();
                ctx.arc(80, canvas.height - 80, 10, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = '#8b0000';
                ctx.beginPath();
                ctx.arc(canvas.width - 80, canvas.height - 80, 10, 0, Math.PI * 2);
                ctx.fill();
            },
            
            drawMerchantRoom: function() {
                // More elaborate merchant room
                ctx.fillStyle = '#daa520';
                ctx.font = '20px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('üè™', canvas.width / 2, 100);
                
                this.drawNormalRoom();
            },
            
            drawStairsRoom: function() {
                // More elaborate stairs room
                ctx.fillStyle = '#daa520';
                ctx.font = '20px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('üè∞', canvas.width / 2, 100);
                
                this.drawNormalRoom();
            },
            
            drawBossRoom: function() {
                // Draw special boss room decorations
                ctx.strokeStyle = '#8b0000';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(canvas.width / 2, canvas.height / 2, 100, 0, Math.PI * 2);
                ctx.stroke();
                
                ctx.fillStyle = '#8b0000';
                ctx.font = '16px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('SALA DO CHEFE', canvas.width / 2, 40);
            },
            
            drawPlayer: function() {
                // Draw player body
                ctx.fillStyle = player.color;
                ctx.beginPath();
                ctx.arc(player.x, player.y, player.size, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw player glow
                ctx.shadowColor = player.color;
                ctx.shadowBlur = 15;
                ctx.fill();
                ctx.shadowBlur = 0;
                
                // Draw player weapon direction
                ctx.strokeStyle = '#daa520';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(player.x, player.y);
                ctx.lineTo(
                    player.x + Math.cos(player.angle) * player.size * 1.5,
                    player.y + Math.sin(player.angle) * player.size * 1.5
                );
                ctx.stroke();
                
                // Draw player class icon
                ctx.fillStyle = '#ffffff';
                ctx.font = '16px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(player.equippedWeapon?.icon || '‚öîÔ∏è', player.x, player.y);
            },
            
            drawEnemies: function() {
                enemies.forEach(enemy => {
                    // Draw enemy body
                    ctx.fillStyle = enemy.color;
                    ctx.beginPath();
                    ctx.arc(enemy.x, enemy.y, enemy.size, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Draw enemy glow
                    ctx.shadowColor = enemy.color;
                    ctx.shadowBlur = 10;
                    ctx.fill();
                    ctx.shadowBlur = 0;
                    
                    // Draw enemy type icon
                    ctx.fillStyle = '#ffffff';
                    ctx.font = '14px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    
                    let enemyIcon = 'üëπ';
                    if (enemy.type === 'skeleton') enemyIcon = 'üíÄ';
                    else if (enemy.type === 'zombie') enemyIcon = 'üßü';
                    else if (enemy.type === 'ghost') enemyIcon = 'üëª';
                    else if (enemy.type === 'wraith') enemyIcon = 'üå´Ô∏è';
                    else if (enemy.type === 'vampire') enemyIcon = 'üßõ';
                    else if (enemy.type === 'lich') enemyIcon = '‚ò†Ô∏è';
                    else if (enemy.type === 'demon') enemyIcon = 'üòà';
                    else if (enemy.type === 'ancient_dragon') enemyIcon = 'üêâ';
                    else if (enemy.type === 'shadow_lord') enemyIcon = 'üëë';
                    
                    ctx.fillText(enemyIcon, enemy.x, enemy.y);
                });
            },
            
            drawItems: function() {
                items.forEach(item => {
                    // Draw item
                    ctx.fillStyle = item.color;
                    ctx.beginPath();
                    ctx.arc(item.x, item.y, item.size, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Draw item glow
                    ctx.shadowColor = item.color;
                    ctx.shadowBlur = 15;
                    ctx.fill();
                    ctx.shadowBlur = 0;
                    
                    // Draw item icon
                    ctx.fillStyle = '#ffffff';
                    ctx.font = '12px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(item.icon, item.x, item.y);
                });
            },
            
            drawProjectiles: function() {
                projectiles.forEach(projectile => {
                    ctx.fillStyle = projectile.color;
                    ctx.beginPath();
                    ctx.arc(projectile.x, projectile.y, projectile.size, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Draw projectile trail
                    ctx.shadowColor = projectile.color;
                    ctx.shadowBlur = 10;
                    ctx.fill();
                    ctx.shadowBlur = 0;
                });
            },
            
            drawParticles: function() {
                particles.forEach(particle => {
                    ctx.globalAlpha = particle.alpha;
                    ctx.fillStyle = particle.color;
                    ctx.beginPath();
                    ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalAlpha = 1;
                });
            },
            
            drawCombatTexts: function() {
                combatTexts.forEach(text => {
                    ctx.globalAlpha = text.alpha;
                    ctx.fillStyle = text.color;
                    ctx.font = 'bold 16px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(text.text, text.x, text.y);
                    ctx.globalAlpha = 1;
                });
            },
            
            // =============================================
            // GAME MECHANICS
            // =============================================
            
            // Initialize a new game
            initGame: function() {
                // Reset game state
                currentFloor = 1;
                currentRoom = 13; // Start in the middle of 5x5 grid
                enemies = [];
                items = [];
                projectiles = [];
                particles = [];
                combatTexts = [];
                roomCleared = false;
                visitedRooms = new Set([13]);
                stairsLocation = null;
                merchantRoom = null;
                
                // Generate first floor
                this.generateFloor();
                
                // Start game loop
                this.loop();
            },
            
            // Generate a floor with rooms - CORRIGIDO para 5x5
            generateFloor: function() {
                rooms = [];
                
                // Generate random special rooms
                const specialRooms = this.generateSpecialRooms();
                stairsLocation = specialRooms.stairs;
                merchantRoom = specialRooms.merchant;
                const bossRoom = specialRooms.boss;
                
                // Generate 5x5 grid (25 rooms)
                for (let i = 1; i <= 25; i++) {
                    let roomType = 'normal';
                    
                    if (i === 13) roomType = 'start';
                    else if (i === stairsLocation) roomType = 'stairs';
                    else if (i === merchantRoom) roomType = 'merchant';
                    else if (i === bossRoom) roomType = 'boss';
                    
                    const room = {
                        type: roomType,
                        enemies: [],
                        cleared: i === 13, // Start room is cleared
                        doors: this.generateDoors(i)
                    };
                    
                    // Add specific content based on room type
                    if (roomType === 'merchant') {
                        room.merchant = {
                            x: canvas.width / 2,
                            y: canvas.height / 2,
                            items: this.generateMerchantItems()
                        };
                        room.cleared = true;
                    } else if (roomType === 'stairs') {
                        room.stairs = {
                            x: canvas.width / 2,
                            y: canvas.height / 2
                        };
                        room.cleared = true;
                    } else if (roomType === 'boss') {
                        room.enemies.push(this.createBoss());
                    } else if (roomType === 'normal' && Math.random() > 0.4) {
                        // 60% chance of enemies in normal rooms
                        const enemyCount = 2 + Math.floor(currentFloor / 2);
                        for (let j = 0; j < enemyCount; j++) {
                            room.enemies.push(this.createEnemy());
                        }
                    }
                    
                    rooms[i] = room;
                }
                
                currentRoom = 13;
                this.generateRoom();
            },
            
            // Generate special rooms for 5x5 grid
            generateSpecialRooms: function() {
                const specialRooms = {
                    stairs: null,
                    merchant: null,
                    boss: null
                };
                
                // Generate unique room numbers (1-25, excluding start room 13)
                const availableRooms = [];
                for (let i = 1; i <= 25; i++) {
                    if (i !== 13) availableRooms.push(i);
                }
                
                // Shuffle and assign
                this.shuffleArray(availableRooms);
                specialRooms.stairs = availableRooms[0];
                specialRooms.merchant = availableRooms[1];
                specialRooms.boss = availableRooms[2];
                
                return specialRooms;
            },
            
            // Shuffle array utility
            shuffleArray: function(array) {
                for (let i = array.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [array[i], array[j]] = [array[j], array[i]];
                }
            },
            
            // Generate doors for a room in 5x5 grid
            generateDoors: function(roomNumber) {
                const row = Math.floor((roomNumber - 1) / 5);
                const col = (roomNumber - 1) % 5;
                
                return {
                    top: row > 0,
                    bottom: row < 4,
                    left: col > 0,
                    right: col < 4
                };
            },
            
            // Generate items for merchant
            generateMerchantItems: function() {
                const items = [];
                const itemCount = 4;
                
                for (let i = 0; i < itemCount; i++) {
                    let item;
                    if (Math.random() < 0.7) { // 70% chance for weapons
                        // Lower chance for rare items from merchant
                        const rarityRoll = Math.random();
                        let rarityIndex;
                        if (rarityRoll < 0.6) rarityIndex = 0; // Common (60%)
                        else if (rarityRoll < 0.9) rarityIndex = 1; // Uncommon (30%)
                        else rarityIndex = 2; // Rare (10%)
                        
                        const weaponPool = weaponTypes.filter(w => 
                            w.rarity === ['common', 'uncommon', 'rare', 'epic', 'legendary'][rarityIndex]
                        );
                        item = {...weaponPool[Math.floor(Math.random() * weaponPool.length)]};
                    } else { // 30% chance for armor
                        const rarityRoll = Math.random();
                        let rarityIndex;
                        if (rarityRoll < 0.6) rarityIndex = 0; // Common (60%)
                        else if (rarityRoll < 0.9) rarityIndex = 1; // Uncommon (30%)
                        else rarityIndex = 2; // Rare (10%)
                        
                        item = {...armorTypes[rarityIndex]};
                    }
                    
                    item.price = this.calculateItemPrice(item);
                    item.merchantItem = true;
                    items.push(item);
                }
                
                // Always add potions
                items.push({
                    name: 'Po√ß√£o de Vida Grande',
                    type: 'potion',
                    health: 100,
                    icon: '‚ù§Ô∏è',
                    price: 50,
                    merchantItem: true
                });
                
                return items;
            },
            
            // Calculate item price based on rarity
            calculateItemPrice: function(item) {
                const basePrice = 50;
                const rarityMultiplier = {
                    'common': 1,
                    'uncommon': 3,
                    'rare': 8,
                    'epic': 20,
                    'legendary': 50
                };
                return basePrice * rarityMultiplier[item.rarity];
            },
            
            // Generate a room with enemies and items
            generateRoom: function() {
                // Clear previous room
                enemies = [];
                items = [];
                roomCleared = rooms[currentRoom]?.cleared || false;
                
                // Add enemies from room definition
                if (rooms[currentRoom]?.enemies) {
                    enemies.push(...rooms[currentRoom].enemies);
                }
                
                // Spawn some random items in normal rooms (chance reduzida)
                if (rooms[currentRoom]?.type === 'normal' && Math.random() < 0.2) {
                    this.spawnRandomItem();
                }
            },
            
            // Create a random enemy based on current floor
            createEnemy: function() {
                const availableEnemies = floorEnemies[currentFloor] || floorEnemies[1];
                const enemyType = availableEnemies[Math.floor(Math.random() * availableEnemies.length)];
                
                const enemyDefinitions = {
                    'skeleton': { name: 'Esqueleto', color: '#c0c0c0', health: 30, damage: 5, speed: 2, size: 20, expReward: 10, goldReward: 5 },
                    'zombie': { name: 'Zumbi', color: '#2d5a27', health: 50, damage: 8, speed: 1, size: 24, expReward: 15, goldReward: 8 },
                    'ghost': { name: 'Fantasma', color: '#7b68ee', health: 25, damage: 6, speed: 3, size: 18, expReward: 12, goldReward: 6 },
                    'wraith': { name: 'Espectro', color: '#4b0082', health: 40, damage: 10, speed: 2.5, size: 22, expReward: 20, goldReward: 12 },
                    'vampire': { name: 'Vampiro', color: '#8b0000', health: 60, damage: 12, speed: 2, size: 26, expReward: 25, goldReward: 15 },
                    'lich': { name: 'Lich', color: '#2f4f4f', health: 80, damage: 15, speed: 1.5, size: 28, expReward: 35, goldReward: 20 },
                    'demon': { name: 'Dem√¥nio', color: '#8b0000', health: 100, damage: 18, speed: 2, size: 30, expReward: 45, goldReward: 25 },
                    'ancient_dragon': { name: 'Drag√£o Ancestral', color: '#dc143c', health: 200, damage: 25, speed: 1.5, size: 40, expReward: 100, goldReward: 50 },
                    'shadow_lord': { name: 'Senhor das Sombras', color: '#000000', health: 150, damage: 22, speed: 2.2, size: 35, expReward: 80, goldReward: 40 }
                };
                
                const baseEnemy = enemyDefinitions[enemyType];
                const floorMultiplier = 1 + (currentFloor - 1) * 0.5;
                
                const enemy = {
                    ...baseEnemy,
                    type: enemyType,
                    x: Math.random() * (canvas.width - 200) + 100,
                    y: Math.random() * (canvas.height - 200) + 100,
                    maxHealth: Math.floor(baseEnemy.health * floorMultiplier),
                    health: Math.floor(baseEnemy.health * floorMultiplier),
                    damage: Math.floor(baseEnemy.damage * floorMultiplier),
                    defense: Math.floor(currentFloor / 2),
                    aggroRange: 200,
                    attackRange: 50,
                    attackSpeed: 60,
                    attackCooldown: 0,
                    expReward: Math.floor(baseEnemy.expReward * floorMultiplier),
                    goldReward: Math.floor(baseEnemy.goldReward * floorMultiplier)
                };
                
                return enemy;
            },
            
            // Create a boss enemy
            createBoss: function() {
                const bossInfo = floorBosses[currentFloor] || floorBosses[1];
                
                const bossDefinitions = {
                    'lich': { name: 'Lich Senhor das Trevas', color: '#4b0082', health: 200, damage: 15, speed: 1.5, size: 40 },
                    'vampire_lord': { name: 'Vampiro Ancestral', color: '#8b0000', health: 250, damage: 20, speed: 2, size: 38 },
                    'skeleton_king': { name: 'Rei Esqueleto', color: '#daa520', health: 300, damage: 18, speed: 1, size: 45 },
                    'abyssal_demon': { name: 'Dem√¥nio do Abismo', color: '#ff4500', health: 350, damage: 25, speed: 1.8, size: 42 },
                    'ancient_dragon': { name: 'Drag√£o Ancestral', color: '#dc143c', health: 500, damage: 30, speed: 1.2, size: 50 }
                };
                
                const baseBoss = bossDefinitions[bossInfo.type];
                const floorMultiplier = 1 + (currentFloor - 1) * 0.8;
                
                const boss = {
                    ...baseBoss,
                    type: bossInfo.type,
                    x: canvas.width / 2,
                    y: canvas.height / 2,
                    maxHealth: Math.floor(baseBoss.health * floorMultiplier),
                    health: Math.floor(baseBoss.health * floorMultiplier),
                    damage: Math.floor(baseBoss.damage * floorMultiplier),
                    defense: 10 + currentFloor * 2,
                    speed: baseBoss.speed,
                    size: baseBoss.size,
                    aggroRange: 300,
                    attackRange: 70,
                    attackSpeed: 90,
                    attackCooldown: 0,
                    expReward: 100 * currentFloor,
                    goldReward: 50 * currentFloor
                };
                
                return boss;
            },
            
            // Enemy attack logic
            enemyAttack: function(enemy) {
                // Simple melee attack for now
                const dx = player.x - enemy.x;
                const dy = player.y - enemy.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance <= enemy.attackRange) {
                    const damage = this.calculateDamage(enemy.damage, player.defense);
                    player.health -= damage;
                    
                    this.addCombatText('-' + damage, player.x, player.y, '#ff0000');
                    this.createParticles(player.x, player.y, 5, '#ff0000');
                    
                    if (player.health <= 0) {
                        this.gameOver();
                    }
                }
            },
            
            // Player attack with weapon
            playerAttack: function() {
                if (player.attackCooldown > 0) return;
                
                // Create projectile based on equipped weapon type
                let projectile;
                const weaponType = player.equippedWeapon?.type || 'sword';
                
                if (weaponType === 'bow' || weaponType === 'staff') {
                    // Ranged attack
                    projectile = {
                        x: player.x,
                        y: player.y,
                        vx: Math.cos(player.angle) * 8,
                        vy: Math.sin(player.angle) * 8,
                        size: weaponType === 'bow' ? 8 : 12,
                        color: weaponType === 'bow' ? '#c0c0c0' : '#9370db',
                        damage: this.calculatePlayerDamage(),
                        lifetime: 60,
                        isEnemy: false
                    };
                    
                    if (weaponType === 'staff' && player.mana >= 10) {
                        player.mana -= 10;
                    } else if (weaponType === 'staff') {
                        return; // Not enough mana
                    }
                } else {
                    // Melee attack
                    projectile = {
                        x: player.x + Math.cos(player.angle) * player.size,
                        y: player.y + Math.sin(player.angle) * player.size,
                        vx: Math.cos(player.angle) * 15,
                        vy: Math.sin(player.angle) * 15,
                        size: 12,
                        color: '#daa520',
                        damage: this.calculatePlayerDamage(),
                        lifetime: 10,
                        isEnemy: false
                    };
                }
                
                projectiles.push(projectile);
                player.attackCooldown = player.attackSpeed;
                
                // Create attack particles
                this.createParticles(
                    player.x + Math.cos(player.angle) * player.size,
                    player.y + Math.sin(player.angle) * player.size,
                    3,
                    weaponType === 'bow' ? '#c0c0c0' : 
                    weaponType === 'staff' ? '#9370db' : '#daa520'
                );
            },
            
            // Calculate player damage
            calculatePlayerDamage: function() {
                let baseDamage = Math.floor(Math.random() * (player.damageMax - player.damageMin + 1)) + player.damageMin;
                
                // Apply weapon damage if equipped
                if (player.equippedWeapon) {
                    const weapon = player.equippedWeapon;
                    baseDamage += Math.floor(Math.random() * (weapon.damage[1] - weapon.damage[0] + 1)) + weapon.damage[0];
                }
                
                return baseDamage;
            },
            
            // Calculate damage with defense
            calculateDamage: function(attack, defense) {
                const damage = attack - defense * 0.5;
                return Math.max(1, Math.floor(damage));
            },
            
            // Check wall collision
            checkWallCollision: function(x, y) {
                const buffer = 10;
                return x < 50 + buffer || x > canvas.width - 50 - buffer || 
                       y < 50 + buffer || y > canvas.height - 50 - buffer;
            },
            
            // Create particles for visual effects
            createParticles: function(x, y, count, color) {
                for (let i = 0; i < count; i++) {
                    particles.push({
                        x: x,
                        y: y,
                        vx: (Math.random() - 0.5) * 4,
                        vy: (Math.random() - 0.5) * 4,
                        size: Math.random() * 3 + 1,
                        color: color,
                        life: 30,
                        maxLife: 30,
                        alpha: 1
                    });
                }
            },
            
            // Add combat text
            addCombatText: function(text, x, y, color) {
                combatTexts.push({
                    text: text,
                    x: x,
                    y: y,
                    color: color,
                    life: 60,
                    maxLife: 60,
                    alpha: 1
                });
            },
            
            // Spawn loot item
            spawnLoot: function(x, y) {
                const lootTypes = [
                    { type: 'health', icon: '‚ù§Ô∏è', color: '#ff0000', name: 'Po√ß√£o de Vida', health: 30 },
                    { type: 'mana', icon: 'üîµ', color: '#1e90ff', name: 'Po√ß√£o de Mana', mana: 30 },
                    { type: 'gold', icon: 'üí∞', color: '#daa520', name: 'Saco de Ouro', gold: 10 }
                ];
                
                const loot = lootTypes[Math.floor(Math.random() * lootTypes.length)];
                loot.x = x;
                loot.y = y;
                loot.size = 10;
                
                items.push(loot);
            },
            
            // Spawn random weapon or armor (chance de raridade ajustada)
            spawnRandomItem: function() {
                const itemTypes = ['weapon', 'armor'];
                const itemType = itemTypes[Math.floor(Math.random() * itemTypes.length)];
                
                let item;
                if (itemType === 'weapon') {
                    // Probabilidades ajustadas - itens raros s√£o mais dif√≠ceis
                    const rarityRoll = Math.random();
                    let rarity;
                    if (rarityRoll < 0.6) rarity = 'common'; // 60%
                    else if (rarityRoll < 0.85) rarity = 'uncommon'; // 25%
                    else if (rarityRoll < 0.95) rarity = 'rare'; // 10%
                    else if (rarityRoll < 0.99) rarity = 'epic'; // 4%
                    else rarity = 'legendary'; // 1%
                    
                    const weaponPool = weaponTypes.filter(w => w.rarity === rarity);
                    item = {...weaponPool[Math.floor(Math.random() * weaponPool.length)]};
                } else {
                    // Probabilidades ajustadas para armaduras tamb√©m
                    const rarityRoll = Math.random();
                    let rarityIndex;
                    if (rarityRoll < 0.6) rarityIndex = 0; // Common (60%)
                    else if (rarityRoll < 0.85) rarityIndex = 1; // Uncommon (25%)
                    else if (rarityRoll < 0.95) rarityIndex = 2; // Rare (10%)
                    else if (rarityRoll < 0.99) rarityIndex = 3; // Epic (4%)
                    else rarityIndex = 4; // Legendary (1%)
                    
                    item = {...armorTypes[rarityIndex]};
                }
                
                item.x = Math.random() * (canvas.width - 150) + 75;
                item.y = Math.random() * (canvas.height - 150) + 75;
                item.size = 12;
                item.type = itemType;
                
                items.push(item);
            },
            
            // Spawn boss chest
            spawnBossChest: function(x, y) {
                const chest = {
                    type: 'chest',
                    icon: 'üéÅ',
                    color: '#daa520',
                    name: 'Ba√∫ do Chefe',
                    x: x,
                    y: y,
                    size: 15,
                    items: this.generateBossLoot()
                };
                
                items.push(chest);
            },
            
            // Generate loot from boss chest (chance de raridade ajustada)
            generateBossLoot: function() {
                const loot = [];
                const itemCount = 2 + Math.floor(Math.random() * 2); // 2-3 items
                
                for (let i = 0; i < itemCount; i++) {
                    const itemType = Math.random() < 0.7 ? 'weapon' : 'armor';
                    let item;
                    
                    if (itemType === 'weapon') {
                        // Boss tem chance maior de dropar itens raros, mas ainda balanceado
                        const rarityRoll = Math.random();
                        let rarity;
                        if (rarityRoll < 0.3) rarity = 'rare'; // 30%
                        else if (rarityRoll < 0.6) rarity = 'epic'; // 30%
                        else if (rarityRoll < 0.85) rarity = 'legendary'; // 25%
                        else rarity = 'uncommon'; // 15% (fallback)
                        
                        const weaponPool = weaponTypes.filter(w => w.rarity === rarity);
                        item = {...weaponPool[Math.floor(Math.random() * weaponPool.length)]};
                    } else {
                        // Similar para armaduras
                        const rarityRoll = Math.random();
                        let rarityIndex;
                        if (rarityRoll < 0.3) rarityIndex = 2; // Rare (30%)
                        else if (rarityRoll < 0.6) rarityIndex = 3; // Epic (30%)
                        else if (rarityRoll < 0.85) rarityIndex = 4; // Legendary (25%)
                        else rarityIndex = 1; // Uncommon (15%)
                        
                        item = {...armorTypes[rarityIndex]};
                    }
                    
                    item.type = itemType;
                    loot.push(item);
                }
                
                return loot;
            },
            
            // Collect item
            collectItem: function(item) {
                if (item.type === 'health') {
                    player.health = Math.min(player.maxHealth, player.health + item.health);
                    this.addCombatText('+' + item.health + ' Vida', player.x, player.y, '#00ff00');
                } else if (item.type === 'mana') {
                    player.mana = Math.min(player.maxMana, player.mana + item.mana);
                    this.addCombatText('+' + item.mana + ' Mana', player.x, player.y, '#1e90ff');
                } else if (item.type === 'gold') {
                    player.gold += item.gold;
                    this.addCombatText('+' + item.gold + ' Ouro', player.x, player.y, '#daa520');
                } else if (item.type === 'chest') {
                    // Open chest
                    item.items.forEach(chestItem => {
                        this.addToInventory(chestItem);
                    });
                    this.addCombatText('Ba√∫ Aberto!', player.x, player.y, '#daa520');
                } else if (item.type === 'weapon' || item.type === 'armor') {
                    this.addToInventory(item);
                }
                
                this.createParticles(item.x, item.y, 5, item.color);
            },
            
            // Add item to inventory
            addToInventory: function(item) {
                if (player.inventory.length < 12) {
                    player.inventory.push(item);
                    this.updateInventoryUI();
                    this.addCombatText(item.name + ' Coletado!', player.x, player.y, '#daa520');
                }
            },
            
            // Update inventory UI
            updateInventoryUI: function() {
                const inventorySlots = document.getElementById('inventory-slots');
                inventorySlots.innerHTML = '';
                
                player.inventory.forEach((item, index) => {
                    const slot = document.createElement('div');
                    slot.className = `inventory-slot item-rarity-${item.rarity || 'common'}`;
                    slot.textContent = item.icon;
                    slot.dataset.index = index;
                    
                    // Add tooltip
                    slot.addEventListener('mouseenter', (e) => {
                        this.showTooltip(e, item);
                    });
                    slot.addEventListener('mouseleave', () => {
                        this.hideTooltip();
                    });
                    
                    // Add click event for equipping
                    slot.addEventListener('click', () => {
                        this.equipItem(index);
                    });
                    
                    inventorySlots.appendChild(slot);
                });
                
                // Fill remaining slots
                for (let i = player.inventory.length; i < 12; i++) {
                    const slot = document.createElement('div');
                    slot.className = 'inventory-slot';
                    inventorySlots.appendChild(slot);
                }
            },
            
            // Equip item
            equipItem: function(inventoryIndex) {
                const item = player.inventory[inventoryIndex];
                
                if (item.type === 'weapon') {
                    // Unequip current weapon
                    if (player.equippedWeapon) {
                        player.inventory.push(player.equippedWeapon);
                    }
                    player.equippedWeapon = item;
                    player.inventory.splice(inventoryIndex, 1);
                    
                    // Update attack speed based on weapon type
                    if (item.type === 'bow' || item.type === 'staff') {
                        player.attackSpeed = 20; // Faster for ranged
                    } else {
                        player.attackSpeed = 25; // Slower for melee
                    }
                } else if (item.type === 'armor') {
                    // Unequip current armor
                    if (player.equippedArmor) {
                        player.inventory.push(player.equippedArmor);
                    }
                    player.equippedArmor = item;
                    player.defense = 5 + (player.equippedArmor ? player.equippedArmor.defense : 0);
                    player.inventory.splice(inventoryIndex, 1);
                }
                
                this.updateInventoryUI();
            },
            
            // Show tooltip
            showTooltip: function(event, item) {
                const tooltip = document.getElementById('tooltip');
                let html = `<div class="tooltip-name tooltip-rarity-${item.rarity || 'common'}">${item.name}</div>`;
                
                if (item.type === 'weapon') {
                    html += `<div class="tooltip-desc">Arma ${item.rarity ? `(${item.rarity})` : ''}</div>`;
                    html += `<div class="tooltip-stats">Dano: ${item.damage[0]}-${item.damage[1]}</div>`;
                    html += `<div class="tooltip-stats">Tipo: ${item.type}</div>`;
                } else if (item.type === 'armor') {
                    html += `<div class="tooltip-desc">Armadura ${item.rarity ? `(${item.rarity})` : ''}</div>`;
                    html += `<div class="tooltip-stats">Defesa: +${item.defense}</div>`;
                } else if (item.merchantItem) {
                    html += `<div class="tooltip-stats">Pre√ßo: ${item.price} ouro</div>`;
                }
                
                tooltip.innerHTML = html;
                tooltip.style.display = 'block';
                tooltip.style.left = (event.pageX + 10) + 'px';
                tooltip.style.top = (event.pageY + 10) + 'px';
            },
            
            // Hide tooltip
            hideTooltip: function() {
                document.getElementById('tooltip').style.display = 'none';
            },
            
            // Open merchant - CORRIGIDO
            openMerchant: function() {
                const merchant = document.getElementById('merchant');
                const merchantItems = document.getElementById('merchant-items');
                const merchantGold = document.getElementById('merchant-gold');
                
                merchantGold.textContent = player.gold;
                merchantItems.innerHTML = '';
                
                if (rooms[currentRoom]?.merchant?.items) {
                    rooms[currentRoom].merchant.items.forEach((item, index) => {
                        const itemElement = document.createElement('div');
                        itemElement.className = `merchant-item item-rarity-${item.rarity || 'common'}`;
                        itemElement.innerHTML = `
                            <div style="font-size: 20px;">${item.icon}</div>
                            <div style="font-size: 10px; margin: 5px 0;">${item.name}</div>
                            <div style="font-size: 9px; color: #daa520;">${item.price} ouro</div>
                        `;
                        
                        itemElement.addEventListener('click', () => {
                            this.buyItem(index);
                        });
                        
                        itemElement.addEventListener('mouseenter', (e) => {
                            this.showTooltip(e, item);
                        });
                        itemElement.addEventListener('mouseleave', () => {
                            this.hideTooltip();
                        });
                        
                        merchantItems.appendChild(itemElement);
                    });
                    
                    merchant.style.display = 'block';
                }
            },
            
            // Buy item from merchant
            buyItem: function(itemIndex) {
                const item = rooms[currentRoom].merchant.items[itemIndex];
                
                if (player.gold >= item.price) {
                    player.gold -= item.price;
                    this.addToInventory({...item});
                    rooms[currentRoom].merchant.items.splice(itemIndex, 1);
                    this.openMerchant(); // Refresh merchant
                } else {
                    this.addCombatText('Ouro Insuficiente!', player.x, player.y, '#ff0000');
                }
            },
            
            // Close merchant
            closeMerchant: function() {
                document.getElementById('merchant').style.display = 'none';
            },
            
            // Move to next floor - CORRIGIDO
            nextFloor: function() {
                currentFloor++;
                if (currentFloor > 5) {
                    // Game completion
                    this.gameComplete();
                    return;
                }
                
                // Heal player
                player.health = player.maxHealth;
                player.mana = player.maxMana;
                
                // Generate new floor
                this.generateFloor();
                
                this.addCombatText('Andar ' + currentFloor + '!', player.x, player.y, '#00ff00');
            },
            
            // Game over
            gameOver: function() {
                gameState = 'gameOver';
                
                // Show game over screen
                document.querySelector('.game-over').style.display = 'flex';
                
                // Update game over stats
                document.getElementById('game-over-stats').innerHTML = `
                    <div>Voc√™ alcan√ßou o n√≠vel ${player.level}</div>
                    <div>E chegou ao andar ${currentFloor} da masmorra</div>
                    <div>Coletou ${player.gold} pe√ßas de ouro</div>
                `;
            },
            
            // Game complete
            gameComplete: function() {
                // Implement game completion logic
                alert('Parab√©ns! Voc√™ completou ShadowCrypt!');
                this.gameOver();
            },
            
            // Use player skill - CORRIGIDO
            useSkill: function(skillIndex) {
                const skill = player.skills[skillIndex];
                
                if (skill.cooldown > 0 || player.mana < skill.manaCost) {
                    return;
                }
                
                player.mana -= skill.manaCost;
                skill.cooldown = skill.cooldownTime;
                
                // Execute skill effect
                if (skill.name === 'Investida') {
                    // Charge attack
                    player.x += Math.cos(player.angle) * 100;
                    player.y += Math.sin(player.angle) * 100;
                    
                    // Damage enemies in path
                    enemies.forEach(enemy => {
                        const dx = enemy.x - player.x;
                        const dy = enemy.y - player.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance < 60) {
                            const damage = this.calculatePlayerDamage() * 2;
                            enemy.health -= damage;
                            this.addCombatText('-' + damage, enemy.x, enemy.y, '#ff0000');
                        }
                    });
                    
                    this.createParticles(player.x, player.y, 20, '#daa520');
                    
                } else if (skill.name === 'Ataque Duplo') {
                    // Double attack
                    for (let i = 0; i < 2; i++) {
                        this.playerAttack();
                    }
                    player.attackCooldown = 0; // Reset cooldown to allow immediate attack
                    
                } else if (skill.name === 'Cura Divina') {
                    // Healing skill
                    const healAmount = 50;
                    player.health = Math.min(player.maxHealth, player.health + healAmount);
                    this.addCombatText('+' + healAmount + ' Vida', player.x, player.y, '#00ff00');
                    this.createParticles(player.x, player.y, 15, '#00ff00');
                }
            }
        };
        
        // =============================================
        // INITIALIZATION & EVENT HANDLERS
        // =============================================
        
        // Initialize the game when page loads
        window.addEventListener('load', function() {
            // Set up event listeners
            setupEventListeners();
            
            // Set up initial UI
            setupUI();
            
            // Create default player
            createDefaultPlayer();
        });
        
        // Set up game event listeners
        function setupEventListeners() {
            // Keyboard input
            window.addEventListener('keydown', function(e) {
                keys[e.key] = true;
                
                // Space bar for attack
                if (e.key === ' ' && gameState === 'playing') {
                    game.playerAttack();
                }
                
                // Number keys for skills
                if (e.key >= '1' && e.key <= '3' && gameState === 'playing') {
                    game.useSkill(parseInt(e.key) - 1);
                }
                
                // E for interactions
                if (e.key === 'e' && gameState === 'playing') {
                    // Mark E as pressed, will be handled in update
                    keys['e'] = true;
                }
                
                // P to pause
                if (e.key === 'p' && gameState === 'playing') {
                    // Pause functionality would go here
                }
            });
            
            window.addEventListener('keyup', function(e) {
                keys[e.key] = false;
            });
            
            // Mouse input
            canvas.addEventListener('mousemove', function(e) {
                const rect = canvas.getBoundingClientRect();
                mouse.x = (e.clientX - rect.left) * (canvas.width / rect.width);
                mouse.y = (e.clientY - rect.top) * (canvas.height / rect.height);
            });
            
            canvas.addEventListener('mousedown', function() {
                mouse.down = true;
                if (gameState === 'playing') {
                    game.playerAttack();
                }
            });
            
            canvas.addEventListener('mouseup', function() {
                mouse.down = false;
            });
            
            // Door click events
            document.querySelectorAll('.door').forEach(door => {
                door.addEventListener('click', function() {
                    if (!this.classList.contains('locked')) {
                        const direction = this.dataset.direction;
                        game.changeRoom(direction);
                    }
                });
            });
            
            // Merchant close button
            document.getElementById('close-merchant').addEventListener('click', function() {
                game.closeMerchant();
            });
            
            // UI button events
            document.getElementById('start-btn').addEventListener('click', function() {
                document.querySelector('.start-screen').style.display = 'none';
                gameState = 'playing';
                game.initGame();
            });
            
            // Restart game
            document.getElementById('restart-btn').addEventListener('click', function() {
                document.querySelector('.game-over').style.display = 'none';
                gameState = 'playing';
                game.initGame();
            });
        }
        
        // Set up initial UI state
        function setupUI() {
            // Create inventory slots
            const inventorySlots = document.getElementById('inventory-slots');
            for (let i = 0; i < 12; i++) {
                const slot = document.createElement('div');
                slot.className = 'inventory-slot';
                slot.textContent = '';
                inventorySlots.appendChild(slot);
            }
            
            // Set up initial quests
            const questList = document.getElementById('quest-list');
            const quests = [
                { text: 'Explore a masmorra', completed: false },
                { text: 'Encontre as escadas para o pr√≥ximo andar', completed: false },
                { text: 'Derrote o Lich Senhor das Trevas', completed: false }
            ];
            
            quests.forEach(quest => {
                const questItem = document.createElement('div');
                questItem.className = 'quest-item';
                questItem.textContent = quest.text;
                questList.appendChild(questItem);
            });
        }
        
        // Create default player (sem classe espec√≠fica)
        function createDefaultPlayer() {
            player = {
                // Stats b√°sicos
                x: canvas.width / 2,
                y: canvas.height / 2,
                size: 20,
                speed: 4,
                color: '#4a4a6a',
                health: 100,
                maxHealth: 100,
                mana: 80,
                maxMana: 80,
                damageMin: 8,
                damageMax: 12,
                defense: 5,
                critChance: 0.05,
                critMultiplier: 1.5,
                attackSpeed: 25,
                attackCooldown: 0,
                
                // Sistema de progress√£o
                level: 1,
                exp: 0,
                expToNextLevel: 100,
                skillPoints: 0,
                gold: 50,
                
                // Invent√°rio e equipamentos
                inventory: [],
                equippedWeapon: null,
                equippedArmor: null,
                
                // Habilidades universais
                skills: [
                    { name: 'Investida', cooldown: 0, cooldownTime: 180, manaCost: 20 },
                    { name: 'Ataque Duplo', cooldown: 0, cooldownTime: 120, manaCost: 15 },
                    { name: 'Cura Divina', cooldown: 0, cooldownTime: 300, manaCost: 30 }
                ]
            };
            
            // Adicionar arma inicial
            const startingWeapon = {...weaponTypes[0]}; // Espada Curta
            startingWeapon.type = 'weapon';
            player.inventory.push(startingWeapon);
            game.equipItem(0);
            
            // Set up skills UI
            const skillSlots = document.getElementById('skill-slots');
            skillSlots.innerHTML = '';
            
            player.skills.forEach((skill, index) => {
                const skillElement = document.createElement('div');
                skillElement.className = 'skill';
                skillElement.innerHTML = `
                    ${skill.name}
                    <span class="skill-cooldown">${skill.manaCost} MP</span>
                `;
                skillElement.addEventListener('click', function() {
                    game.useSkill(index);
                });
                skillSlots.appendChild(skillElement);
            });
        }
    </script>
</body>
</html>
