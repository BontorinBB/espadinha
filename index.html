<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Isaac-like Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: #1a1a2e;
            color: #fff;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }

        .game-container {
            position: relative;
            width: 800px;
            height: 600px;
            background: #0f0f1a;
            border: 4px solid #4a0e4e;
            box-shadow: 0 0 30px rgba(148, 0, 211, 0.5);
            overflow: hidden;
        }

        #game-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        .ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        .health-container {
            position: absolute;
            top: 20px;
            left: 20px;
            display: flex;
            gap: 10px;
        }

        .heart {
            width: 30px;
            height: 30px;
            background: #ff4757;
            clip-path: polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%);
            box-shadow: 0 0 10px #ff4757;
        }

        .heart.empty {
            background: #2f3542;
            box-shadow: 0 0 5px #2f3542;
        }

        .stats {
            position: absolute;
            top: 20px;
            right: 20px;
            text-align: right;
            font-size: 18px;
            text-shadow: 0 0 5px #000;
        }

        .room-info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            font-size: 16px;
            text-shadow: 0 0 5px #000;
        }

        .controls {
            position: absolute;
            bottom: 20px;
            right: 20px;
            font-size: 14px;
            text-align: right;
            text-shadow: 0 0 5px #000;
        }

        .screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(10, 10, 20, 0.95);
            z-index: 20;
        }

        .title {
            font-size: 48px;
            color: #ff4757;
            text-shadow: 0 0 20px #ff4757;
            margin-bottom: 20px;
            font-weight: bold;
        }

        .subtitle {
            font-size: 24px;
            color: #a55eea;
            margin-bottom: 40px;
        }

        .btn {
            background: #4a0e4e;
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 20px;
            font-family: 'Courier New', monospace;
            cursor: pointer;
            margin: 10px;
            border: 2px solid #a55eea;
            transition: all 0.3s;
            box-shadow: 0 0 15px rgba(165, 94, 234, 0.5);
        }

        .btn:hover {
            background: #a55eea;
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(165, 94, 234, 0.8);
        }

        .game-over {
            display: none;
        }

        .power-ups {
            position: absolute;
            top: 70px;
            left: 20px;
            display: flex;
            gap: 10px;
        }

        .power-up {
            width: 25px;
            height: 25px;
            border-radius: 50%;
            border: 2px solid #ffa502;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 14px;
            color: #ffa502;
            text-shadow: 0 0 5px #ffa502;
        }

        .minimap {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 150px;
            height: 100px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #a55eea;
        }

        .instructions {
            max-width: 600px;
            text-align: center;
            margin-top: 20px;
            line-height: 1.6;
            color: #70a1ff;
        }

        .hidden {
            display: none;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <canvas id="game-canvas" width="800" height="600"></canvas>
        
        <div class="ui-overlay">
            <div class="health-container" id="health-container">
                <!-- Hearts will be added here -->
            </div>
            
            <div class="stats">
                <div id="score">Score: 0</div>
                <div id="floor">Floor: 1</div>
            </div>
            
            <div class="power-ups" id="power-ups">
                <!-- Power-ups will be added here -->
            </div>
            
            <div class="room-info">
                <div id="room-type">Room: Start</div>
                <div id="enemies-left">Enemies: 0</div>
            </div>
            
            <div class="minimap" id="minimap"></div>
            
            <div class="controls">
                <div>WASD - Move</div>
                <div>Arrow Keys - Shoot</div>
                <div>Space - Use Item</div>
                <div>P - Pause</div>
            </div>
        </div>
        
        <div class="screen start-screen">
            <div class="title">BINDING OF DARKNESS</div>
            <div class="subtitle">A TBoI-inspired Roguelike</div>
            <button class="btn" id="start-btn">Start Game</button>
            <button class="btn" id="instructions-btn">Instructions</button>
            
            <div class="instructions hidden" id="instructions">
                <h3>How to Play:</h3>
                <p>Explore rooms, defeat enemies, and collect power-ups.</p>
                <p>Find the treasure room on each floor to progress.</p>
                <p>Defeat all enemies in a room to unlock doors.</p>
                <p>Collect hearts to restore health.</p>
                <p>Good luck!</p>
            </div>
        </div>
        
        <div class="screen game-over">
            <div class="title">GAME OVER</div>
            <div class="subtitle" id="final-score">Score: 0</div>
            <button class="btn" id="restart-btn">Play Again</button>
        </div>
        
        <div class="screen pause-screen hidden">
            <div class="title">PAUSED</div>
            <button class="btn" id="resume-btn">Resume</button>
            <button class="btn" id="menu-btn">Main Menu</button>
        </div>
    </div>

    <script>
        // Game elements
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        const startScreen = document.querySelector('.start-screen');
        const gameOverScreen = document.querySelector('.game-over');
        const pauseScreen = document.querySelector('.pause-screen');
        const healthContainer = document.getElementById('health-container');
        const scoreDisplay = document.getElementById('score');
        const floorDisplay = document.getElementById('floor');
        const roomTypeDisplay = document.getElementById('room-type');
        const enemiesLeftDisplay = document.getElementById('enemies-left');
        const powerUpsContainer = document.getElementById('power-ups');
        const finalScoreDisplay = document.getElementById('final-score');
        const instructions = document.getElementById('instructions');

        // Game state
        let gameState = 'menu'; // menu, playing, paused, gameover
        let player = {};
        let rooms = [];
        let currentRoom = 0;
        let enemies = [];
        let projectiles = [];
        let items = [];
        let score = 0;
        let floor = 1;

        // Initialize game
        function initGame() {
            // Create player
            player = {
                x: 400,
                y: 300,
                size: 20,
                speed: 5,
                health: 6,
                maxHealth: 6,
                damage: 1,
                tears: 1, // Number of projectiles
                tearSpeed: 7,
                tearSize: 8,
                shotSpeed: 15, // Frames between shots
                lastShot: 0,
                direction: { x: 0, y: 0 },
                color: '#70a1ff'
            };

            // Generate rooms
            generateFloor();
            
            // Reset game state
            enemies = [];
            projectiles = [];
            items = [];
            score = 0;
            floor = 1;
            
            updateUI();
        }

        // Generate a floor with rooms
        function generateFloor() {
            rooms = [];
            
            // Create different room types
            const roomTypes = ['start', 'normal', 'normal', 'normal', 'treasure', 'boss'];
            
            for (let i = 0; i < roomTypes.length; i++) {
                const room = {
                    type: roomTypes[i],
                    enemies: [],
                    cleared: i === 0, // Start room is cleared
                    doors: {
                        top: i > 0 && i !== 3,
                        right: i < roomTypes.length - 1,
                        bottom: i < roomTypes.length - 2,
                        left: i > 1
                    }
                };
                
                // Add enemies to normal and boss rooms
                if (room.type === 'normal') {
                    const enemyCount = Math.floor(Math.random() * 3) + 2;
                    for (let j = 0; j < enemyCount; j++) {
                        room.enemies.push(createEnemy(room.type));
                    }
                } else if (room.type === 'boss') {
                    room.enemies.push(createEnemy('boss'));
                }
                
                // Add items to treasure room
                if (room.type === 'treasure') {
                    items.push(createItem(room.type));
                }
                
                rooms.push(room);
            }
            
            currentRoom = 0;
            updateRoomDisplay();
        }

        // Create an enemy
        function createEnemy(type) {
            const x = Math.random() * 600 + 100;
            const y = Math.random() * 400 + 100;
            
            let enemy = {
                x: x,
                y: y,
                size: type === 'boss' ? 40 : 20,
                speed: type === 'boss' ? 2 : 3,
                health: type === 'boss' ? 10 : 3,
                damage: type === 'boss' ? 2 : 1,
                color: type === 'boss' ? '#ff4757' : '#ffa502',
                lastMove: 0,
                moveCooldown: type === 'boss' ? 20 : 30
            };
            
            return enemy;
        }

        // Create an item
        function createItem(type) {
            const items = [
                { name: 'Damage Up', color: '#ff4757', effect: 'damage' },
                { name: 'Speed Up', color: '#70a1ff', effect: 'speed' },
                { name: 'Health Up', color: '#2ed573', effect: 'health' },
                { name: 'Tears Up', color: '#a55eea', effect: 'tears' }
            ];
            
            const item = items[Math.floor(Math.random() * items.length)];
            item.x = Math.random() * 600 + 100;
            item.y = Math.random() * 400 + 100;
            item.size = 15;
            
            return item;
        }

        // Update UI elements
        function updateUI() {
            // Update health
            healthContainer.innerHTML = '';
            for (let i = 0; i < player.maxHealth; i++) {
                const heart = document.createElement('div');
                heart.className = i < player.health ? 'heart' : 'heart empty';
                healthContainer.appendChild(heart);
            }
            
            // Update score and floor
            scoreDisplay.textContent = `Score: ${score}`;
            floorDisplay.textContent = `Floor: ${floor}`;
            
            // Update power-ups
            powerUpsContainer.innerHTML = '';
            if (player.damage > 1) {
                const powerUp = document.createElement('div');
                powerUp.className = 'power-up';
                powerUp.textContent = 'âš”ï¸';
                powerUp.title = 'Damage Up';
                powerUpsContainer.appendChild(powerUp);
            }
            if (player.speed > 5) {
                const powerUp = document.createElement('div');
                powerUp.className = 'power-up';
                powerUp.textContent = 'ðŸ‘Ÿ';
                powerUp.title = 'Speed Up';
                powerUpsContainer.appendChild(powerUp);
            }
            if (player.tears > 1) {
                const powerUp = document.createElement('div');
                powerUp.className = 'power-up';
                powerUp.textContent = 'ðŸ’§';
                powerUp.title = 'Tears Up';
                powerUpsContainer.appendChild(powerUp);
            }
        }

        // Update room display
        function updateRoomDisplay() {
            const room = rooms[currentRoom];
            roomTypeDisplay.textContent = `Room: ${room.type.charAt(0).toUpperCase() + room.type.slice(1)}`;
            
            const enemyCount = room.enemies.length;
            enemiesLeftDisplay.textContent = `Enemies: ${enemyCount}`;
            
            // Update enemies array for current room
            enemies = [...room.enemies];
        }

        // Draw game elements
        function draw() {
            // Clear canvas
            ctx.fillStyle = '#0f0f1a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw room
            drawRoom();
            
            // Draw items
            items.forEach(item => {
                ctx.fillStyle = item.color;
                ctx.beginPath();
                ctx.arc(item.x, item.y, item.size, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw glow
                ctx.shadowColor = item.color;
                ctx.shadowBlur = 15;
                ctx.fill();
                ctx.shadowBlur = 0;
            });
            
            // Draw player
            ctx.fillStyle = player.color;
            ctx.beginPath();
            ctx.arc(player.x, player.y, player.size, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw player direction indicator
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(player.x, player.y);
            ctx.lineTo(
                player.x + player.direction.x * player.size * 1.5,
                player.y + player.direction.y * player.size * 1.5
            );
            ctx.stroke();
            
            // Draw enemies
            enemies.forEach(enemy => {
                ctx.fillStyle = enemy.color;
                ctx.beginPath();
                ctx.arc(enemy.x, enemy.y, enemy.size, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw health bar for bosses
                if (enemy.size === 40) {
                    const barWidth = 60;
                    const barHeight = 6;
                    const barX = enemy.x - barWidth / 2;
                    const barY = enemy.y - enemy.size - 10;
                    
                    // Background
                    ctx.fillStyle = '#2f3542';
                    ctx.fillRect(barX, barY, barWidth, barHeight);
                    
                    // Health
                    const healthWidth = (enemy.health / 10) * barWidth;
                    ctx.fillStyle = '#ff4757';
                    ctx.fillRect(barX, barY, healthWidth, barHeight);
                }
            });
            
            // Draw projectiles
            projectiles.forEach(projectile => {
                ctx.fillStyle = projectile.color;
                ctx.beginPath();
                ctx.arc(projectile.x, projectile.y, projectile.size, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw glow
                ctx.shadowColor = projectile.color;
                ctx.shadowBlur = 10;
                ctx.fill();
                ctx.shadowBlur = 0;
            });
        }

        // Draw room with doors
        function drawRoom() {
            const room = rooms[currentRoom];
            
            // Draw walls
            ctx.strokeStyle = '#4a0e4e';
            ctx.lineWidth = 10;
            ctx.strokeRect(50, 50, 700, 500);
            
            // Draw doors
            ctx.fillStyle = '#0f0f1a';
            ctx.strokeStyle = '#a55eea';
            ctx.lineWidth = 4;
            
            if (room.doors.top) {
                ctx.fillRect(350, 45, 100, 10);
                ctx.strokeRect(350, 45, 100, 10);
            }
            
            if (room.doors.right) {
                ctx.fillRect(745, 250, 10, 100);
                ctx.strokeRect(745, 250, 10, 100);
            }
            
            if (room.doors.bottom) {
                ctx.fillRect(350, 545, 100, 10);
                ctx.strokeRect(350, 545, 100, 10);
            }
            
            if (room.doors.left) {
                ctx.fillRect(45, 250, 10, 100);
                ctx.strokeRect(45, 250, 10, 100);
            }
        }

        // Game loop
        function gameLoop() {
            if (gameState !== 'playing') return;
            
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }

        // Update game state
        function update() {
            // Move player
            if (keys['w'] || keys['ArrowUp']) {
                player.y -= player.speed;
                player.direction = { x: 0, y: -1 };
            }
            if (keys['s'] || keys['ArrowDown']) {
                player.y += player.speed;
                player.direction = { x: 0, y: 1 };
            }
            if (keys['a'] || keys['ArrowLeft']) {
                player.x -= player.speed;
                player.direction = { x: -1, y: 0 };
            }
            if (keys['d'] || keys['ArrowRight']) {
                player.x += player.speed;
                player.direction = { x: 1, y: 0 };
            }
            
            // Keep player in bounds
            player.x = Math.max(player.size, Math.min(canvas.width - player.size, player.x));
            player.y = Math.max(player.size, Math.min(canvas.height - player.size, player.y));
            
            // Shooting
            if ((keys['ArrowUp'] || keys['ArrowDown'] || keys['ArrowLeft'] || keys['ArrowRight']) && 
                Date.now() - player.lastShot > 1000 / (player.shotSpeed / 10)) {
                shoot();
                player.lastShot = Date.now();
            }
            
            // Move projectiles
            projectiles.forEach((projectile, index) => {
                projectile.x += projectile.vx;
                projectile.y += projectile.vy;
                
                // Remove if out of bounds
                if (projectile.x < 0 || projectile.x > canvas.width || 
                    projectile.y < 0 || projectile.y > canvas.height) {
                    projectiles.splice(index, 1);
                }
                
                // Check collision with enemies
                enemies.forEach((enemy, enemyIndex) => {
                    const dx = projectile.x - enemy.x;
                    const dy = projectile.y - enemy.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < projectile.size + enemy.size) {
                        // Hit enemy
                        enemy.health -= player.damage;
                        projectiles.splice(index, 1);
                        
                        if (enemy.health <= 0) {
                            // Enemy defeated
                            enemies.splice(enemyIndex, 1);
                            rooms[currentRoom].enemies = enemies;
                            score += enemy.size === 40 ? 100 : 10;
                            
                            // Spawn heart sometimes
                            if (Math.random() < 0.2) {
                                items.push({
                                    x: enemy.x,
                                    y: enemy.y,
                                    size: 10,
                                    color: '#ff4757',
                                    type: 'heart'
                                });
                            }
                            
                            updateUI();
                            updateRoomDisplay();
                            
                            // Check if room is cleared
                            if (enemies.length === 0) {
                                rooms[currentRoom].cleared = true;
                                
                                // If boss room, go to next floor
                                if (rooms[currentRoom].type === 'boss') {
                                    setTimeout(() => {
                                        floor++;
                                        generateFloor();
                                        player.health = player.maxHealth; // Heal between floors
                                        updateUI();
                                    }, 2000);
                                }
                            }
                        }
                    }
                });
            });
            
            // Move enemies
            enemies.forEach(enemy => {
                if (Date.now() - enemy.lastMove > enemy.moveCooldown * 10) {
                    // Simple AI: move toward player
                    const dx = player.x - enemy.x;
                    const dy = player.y - enemy.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance > 0) {
                        enemy.x += (dx / distance) * enemy.speed;
                        enemy.y += (dy / distance) * enemy.speed;
                    }
                    
                    enemy.lastMove = Date.now();
                }
                
                // Check collision with player
                const dx = player.x - enemy.x;
                const dy = player.y - enemy.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < player.size + enemy.size) {
                    // Player hit
                    player.health -= enemy.damage;
                    updateUI();
                    
                    // Knockback
                    player.x += (dx / distance) * 20;
                    player.y += (dy / distance) * 20;
                    
                    if (player.health <= 0) {
                        gameOver();
                    }
                }
            });
            
            // Check item collection
            items.forEach((item, index) => {
                const dx = player.x - item.x;
                const dy = player.y - item.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < player.size + item.size) {
                    // Collect item
                    if (item.type === 'heart') {
                        player.health = Math.min(player.maxHealth, player.health + 2);
                    } else {
                        applyPowerUp(item);
                    }
                    
                    items.splice(index, 1);
                    updateUI();
                }
            });
            
            // Check room transitions
            const room = rooms[currentRoom];
            if (room.cleared) {
                if (player.y < 60 && room.doors.top) {
                    currentRoom = Math.max(0, currentRoom - 1);
                    player.y = canvas.height - 60;
                    updateRoomDisplay();
                } else if (player.y > canvas.height - 60 && room.doors.bottom) {
                    currentRoom = Math.min(rooms.length - 1, currentRoom + 1);
                    player.y = 60;
                    updateRoomDisplay();
                } else if (player.x > canvas.width - 60 && room.doors.right) {
                    currentRoom = Math.min(rooms.length - 1, currentRoom + 1);
                    player.x = 60;
                    updateRoomDisplay();
                } else if (player.x < 60 && room.doors.left) {
                    currentRoom = Math.max(0, currentRoom - 1);
                    player.x = canvas.width - 60;
                    updateRoomDisplay();
                }
            }
        }

        // Shoot projectile
        function shoot() {
            for (let i = 0; i < player.tears; i++) {
                const spread = player.tears > 1 ? 0.2 : 0;
                const angle = Math.atan2(player.direction.y, player.direction.x) + 
                             (Math.random() * spread - spread / 2);
                
                projectiles.push({
                    x: player.x,
                    y: player.y,
                    vx: Math.cos(angle) * player.tearSpeed,
                    vy: Math.sin(angle) * player.tearSpeed,
                    size: player.tearSize,
                    color: '#70a1ff',
                    damage: player.damage
                });
            }
        }

        // Apply power-up effect
        function applyPowerUp(item) {
            switch(item.effect) {
                case 'damage':
                    player.damage += 0.5;
                    break;
                case 'speed':
                    player.speed += 1;
                    break;
                case 'health':
                    player.maxHealth += 2;
                    player.health = player.maxHealth;
                    break;
                case 'tears':
                    player.tears += 1;
                    break;
            }
            
            score += 50;
        }

        // Game over
        function gameOver() {
            gameState = 'gameover';
            finalScoreDisplay.textContent = `Score: ${score}`;
            gameOverScreen.style.display = 'flex';
        }

        // Input handling
        const keys = {};

        window.addEventListener('keydown', (e) => {
            keys[e.key] = true;
            
            // Pause game
            if (e.key === 'p' && gameState === 'playing') {
                gameState = 'paused';
                pauseScreen.classList.remove('hidden');
            }
        });

        window.addEventListener('keyup', (e) => {
            keys[e.key] = false;
        });

        // Button event listeners
        document.getElementById('start-btn').addEventListener('click', () => {
            startScreen.style.display = 'none';
            gameState = 'playing';
            initGame();
            gameLoop();
        });

        document.getElementById('instructions-btn').addEventListener('click', () => {
            instructions.classList.toggle('hidden');
        });

        document.getElementById('restart-btn').addEventListener('click', () => {
            gameOverScreen.style.display = 'none';
            gameState = 'playing';
            initGame();
            gameLoop();
        });

        document.getElementById('resume-btn').addEventListener('click', () => {
            pauseScreen.classList.add('hidden');
            gameState = 'playing';
            gameLoop();
        });

        document.getElementById('menu-btn').addEventListener('click', () => {
            pauseScreen.classList.add('hidden');
            startScreen.style.display = 'flex';
            gameState = 'menu';
        });

        // Initial draw
        draw();
    </script>
</body>
</html>
